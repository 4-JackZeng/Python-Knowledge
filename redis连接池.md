###  redis连接池

为什么使用连接池:假设Redis服务器与客户端分处在异地，虽然基于内存的Redis数据库有着超高的性能，但是底层的网络通信却占用了一次数据请求的大量时间，因为每次数据交互都需要先建立连接，假设一次数据交互总共用时30ms，超高性能的Redis数据库处理数据所花的时间可能不到1ms，也即是说前期的连接占用了29ms，连接池则可以实现在客户端建立多个链接并且不释放，当需要使用连接的时候通过一定的算法获取已经建立的连接，使用完了以后则还给连接池，这就免去了数据库连接所占用的时间。



















##### 基本IO模型

网上搜了很多关于同步异步，阻塞非阻塞的说法，理解还是不能很透彻，有必要买书看下。
 参考：[使用异步 I/O 大大提高应用程序的性能](https://link.jianshu.com?t=https://www.ibm.com/developerworks/cn/linux/l-async/)
 [怎样理解阻塞非阻塞与同步异步的区别？](https://link.jianshu.com?t=https://www.zhihu.com/question/19732473)

1. 同步和异步：主要关注消息通信机制（重点在B？）。
    同步：A调用B，B处理直到获得结果，才返回给A。
    异步：A调用B，B直接返回。无需等待结果，B通过状态，通知等来通知A或回调函数来处理。
2. 阻塞和非阻塞：主要关注程序等待（重点在A？）。
    阻塞：A调用B，A被挂起直到B返回结果给A，A继续执行。
    非阻塞：A调用B，A不会被挂起，A可以执行其他操作（但可能A需要轮询检查B是否返回）。
3. 同步阻塞：A调用B，A挂起，B处理直到获得结果，返回给A，A继续执行。
4. 同步非阻塞：A调用B，A继续执行，B处理直到获得结果，处理的同时A轮询检查B是否返回结果。
5. 异步阻塞：异步阻塞 I/O 模型的典型流程 (select)。
6. 异步非阻塞：A调用B，B立即返回，A继续执行，B得到结果后通过状态，通知等通知A或回调函数处理。

##### 

 

 

 

 

 